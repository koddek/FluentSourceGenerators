using System.Collections.Immutable;
using FluentSourceGenerators;
using Microsoft.CodeAnalysis;
using System.Linq;
using FluentSourceGenerators.Tests;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FluentSourceGenerators.Tests;

public record PropertyModel(string Name);

public record DumperModel(string Namespace, string ClassName, EquatableArray<PropertyModel> Properties);

[Generator]
public class DumpGenerator : IIncrementalGenerator
{
    public const string DumpableAttr =
        "namespace Demo { [System.AttributeUsage(System.AttributeTargets.Class)] public class DumpableAttribute : System.Attribute {} }";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalGeneratorBuilder.Create()
            .AddPostInitialization(ctx => ctx.AddSource("DumpableAttribute.g.cs", DumpableAttr))
            .StartSyntaxPipeline<DumperModel>()
            .WithPredicate((node, _) => node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0)
            .WithTransform((ctx, ct) =>
            {
                var node = (ClassDeclarationSyntax)ctx.Node;

                // FIX 1: Cast to INamedTypeSymbol to access GetMembers()
                if (ctx.SemanticModel.GetDeclaredSymbol(node) is not INamedTypeSymbol symbol)
                    return GenResult<DumperModel>.Fail(Diagnostic.Create(
                        new DiagnosticDescriptor("DUMP00", "Err", "Symbol not found", "Usage", DiagnosticSeverity.Error,
                            true), node.GetLocation()));

                if (!symbol.GetAttributes().Any(a => a.AttributeClass?.Name == "DumpableAttribute"))
                {
                    // Return a hidden diagnostic to filter this out smoothly
                    return GenResult<DumperModel>.Fail(Diagnostic.Create(
                        new DiagnosticDescriptor("DUMP00", "Ignore", "Ignore", "Usage", DiagnosticSeverity.Hidden,
                            true),
                        node.GetLocation()));
                }

                var props = symbol.GetMembers().OfType<IPropertySymbol>()
                    .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public)
                    .Select(p => new PropertyModel(p.Name))
                    .ToImmutableArray();

                return new DumperModel(
                    symbol.ContainingNamespace.ToDisplayString(),
                    symbol.Name,
                    new EquatableArray<PropertyModel>(props));
            })
            .WithOutput((spc, model, ct) =>
            {
                var sb = new StringBuilder();
                var propertyLines = new StringBuilder();

                // FIX 2: Iterate over .Array, not the struct itself
                foreach (var prop in model.Properties.Array)
                {
                    var line = $"            sb.AppendLine($\"  {prop.Name}: {{this.{prop.Name}}}\");";
                    propertyLines.AppendLine(line);
                }

                var code = $$"""
                             // <auto-generated/>
                             using System.Text;
                             namespace {{model.Namespace}} 
                             {
                                 partial class {{model.ClassName}} 
                                 {
                                     public string Dump() 
                                     {
                                         var sb = new StringBuilder();
                                         sb.AppendLine("{");
                             {{propertyLines}}
                                         sb.AppendLine("}");
                                         return sb.ToString();
                                     }
                                 }
                             }
                             """;

                spc.AddSource($"{model.ClassName}.Dump.g.cs", code);
            })
            .And()
            .Build()
            .Initialize(context);
    }
}

public class DumpGeneratorTest
{
    [Test]
    public async Task Dump_GeneratesJsonLikeStructure()
    {
        // We need to include the "Demo" namespace usage because the attribute is generated there
        var input = """
                    using Demo;
                    namespace App;

                    [Dumpable]
                    public partial class User {
                        public string Name { get; set; }
                        public int Age { get; set; }
                    }
                    """;

        // Run the generator
        var (diags, output) = TestHelpers.RunGenerator<DumpGenerator>(input);

        // Assert
        // We expect 'diags' to be empty of ERRORS.
        // (If you filtered using a Hidden diagnostic in Transform, check severity)
        var errors = diags.Where(d => d.Severity == DiagnosticSeverity.Error);
        await Assert.That(errors).IsEmpty();

        // Verify output contains the generated properties
        await Assert.That(output).Contains("Name: {this.Name}");
        await Assert.That(output).Contains("Age: {this.Age}");
        await Assert.That(output).Contains("public string Dump()");
    }
}
